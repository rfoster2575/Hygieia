package com.capitalone.dashboard.utils;

import com.capitalone.dashboard.model.vulnerability.ArtifactType;
import com.capitalone.dashboard.model.vulnerability.JenkinsJob;
import com.capitalone.dashboard.model.vulnerability.JenkinsVulnerabilityJob;
import com.capitalone.dashboard.model.LibraryPolicyResult;
import com.capitalone.dashboard.model.LibraryPolicyType;
import com.capitalone.dashboard.model.LibraryPolicyThreatLevel;
import com.capitalone.dashboard.repository.LibraryPolicyResultsRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import org.w3c.dom.Document;
import org.w3c.dom.NodeList;
import org.w3c.dom.Node;
import org.w3c.dom.Element;
import org.xml.sax.InputSource;
import java.io.StringReader;

import org.json.JSONArray;
import org.json.JSONObject;
import org.json.JSONException;
import java.util.Map;


@Component
public class VulnerabilityDataService implements VulnerabilityService {

    private static final Logger LOGGER = LoggerFactory.getLogger(VulnerabilityDataService.class);

    private LibraryPolicyResultsRepository libraryPolicyRepository;
    
    @Autowired
    public VulnerabilityDataService(LibraryPolicyResultsRepository libraryPolicyRepository) {
        this.libraryPolicyRepository = libraryPolicyRepository;
    }

    @Override
    public void storeLibraryPolicy(JenkinsJob jobName, JenkinsVulnerabilityJob job, Map<ArtifactType, String> artifactTypeReportMap) {
        artifactTypeReportMap.forEach((type, policyReport) -> {
            if (null != policyReport && null != job) {
                LibraryPolicyResult lpr = createLibraryPolicy(jobName, job, type, policyReport);
                
                // store the data only if it doesn't already exist
                if (lpr != null && isNewReport(job, lpr.getEvaluationTimestamp())) {
                    LOGGER.info("Storing new job " + job.getId() + " at timestamp " + lpr.getEvaluationTimestamp());
                    libraryPolicyRepository.save(lpr);
                }    
                
            }
        });
    }

    private boolean isNewReport(JenkinsVulnerabilityJob job, long newReportTime) {
        return null == libraryPolicyRepository.findByCollectorItemIdAndTimestamp(job.getId(), newReportTime);
    }

    private LibraryPolicyResult createLibraryPolicy(JenkinsJob jobName, JenkinsVulnerabilityJob job, ArtifactType type, String policyReport) {
        LibraryPolicyResult lpr = null;
        if (type == ArtifactType.owasp) {
            lpr = createLibraryPolicyFromOwasp(policyReport);
        } else if (type == ArtifactType.retirejs) {
            lpr = createLibraryPolicyFromRetirejs(policyReport);
        }

        if (lpr != null) {
            lpr.setCollectorItemId(job.getId());
            lpr.setReportUrl(jobName.getUrl());
            lpr.setEvaluationTimestamp(jobName.getLastSuccessfulBuild().getTimestamp());
            lpr.setTimestamp(jobName.getLastSuccessfulBuild().getTimestamp());
        }

        return lpr;
    }

    private LibraryPolicyResult createLibraryPolicyFromOwasp(String owaspReport) {

        LibraryPolicyResult policyResult = null;
        try {
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            InputSource is = new InputSource(new StringReader(owaspReport));
            
            Document doc = builder.parse(is);
            doc.getDocumentElement().normalize();
                    
            policyResult = new LibraryPolicyResult();

            NodeList vulnerabilityList = doc.getElementsByTagName("vulnerability");
            for (int i = 0; i < vulnerabilityList.getLength(); i++) {
                Node vulnerabilityNode = vulnerabilityList.item(i);

                String componentName = getComponentName(vulnerabilityNode);

                Element vulnerability = (Element) vulnerabilityNode;
                double securityLevel = Double.parseDouble(vulnerability.getElementsByTagName("cvssScore").item(0).getTextContent());
                policyResult.addThreat(LibraryPolicyType.Security, LibraryPolicyThreatLevel.fromDouble(securityLevel), componentName);
            }
            
            return policyResult;
        } catch (Exception ex) {
            LOGGER.error("Error Parsring Owasp XML report" + ex.getMessage());
        }
        return policyResult;
        
    }

    private LibraryPolicyResult createLibraryPolicyFromRetirejs(String retirejsJson) {

        LibraryPolicyResult policyResult = new LibraryPolicyResult();
        try {
            JSONArray jsonArray = new JSONArray(retirejsJson);

            jsonArray.forEach((jsonObject) -> {
                JSONArray resultsArray = getJSONArray((JSONObject) jsonObject,"results");
                resultsArray.forEach((resultObject) -> {
                    JSONObject result = (JSONObject)resultObject;

                    String componentName = getComponentName(result);
                    JSONArray vulnerabilityArray = getJSONArray((JSONObject) result,"vulnerabilities");
                    vulnerabilityArray.forEach((vulnerabilityObject) -> {
                        String severity = getJSONValue((JSONObject) vulnerabilityObject, "severity");
                        policyResult.addThreat(LibraryPolicyType.Security, LibraryPolicyThreatLevel.fromString(severity), componentName);
                    });
                });
            });
        } catch (JSONException ex) {
            LOGGER.error("Error Parsing Retirejs.json" + ex.getMessage());
        }

        return policyResult;
    }

    private String getComponentName(Node vulnerabilityNode) {
        String componentName = "";
        try {
            Node dependencyNode = vulnerabilityNode.getParentNode().getParentNode();
            if ("dependency".equals(dependencyNode.getNodeName())) {
                Element dependency = (Element) dependencyNode;
                componentName = dependency.getElementsByTagName("fileName").item(0).getTextContent();
            }
        } catch (Exception ex) {
            LOGGER.error("Error geeting parent dependency node" + ex.getMessage());
        }
        return componentName;
    }

    private String getComponentName(JSONObject jsonObject) {
        String version = getJSONValue(jsonObject, "version");
        String component = getJSONValue(jsonObject, "component");
        return component + "-" + version;
    }

    private JSONArray getJSONArray(JSONObject jsonObject, String key) {
        return (jsonObject.has(key)) ? jsonObject.getJSONArray(key) : new JSONArray();
    }

    private String getJSONValue(JSONObject jsonObject, String key) {
        return (jsonObject.has(key)) ? jsonObject.getString(key) : "";
    }
}
